/*******************************************************************************
********************************************************************************
 *
 *  Author:           Lingurar Petru-Mugurel
 *  Written:          27 Jul 2015, 20:11:20:768
 *  Last updated:     06 Aug 2015, 19:15:18:441 
 *
 *  Compilation:  g++ -std=c++14 -Wall -Werror -Wextra -pedantic -Wshadow
 *   (g++ 5.1)        -Woverloaded-virtual -Winvalid-pch -Wcast-align
 *                    -Wformat=2 -Wformat-nonliteral -Wmissing-declarations
 *                    -Wmissing-format-attribute -Wmissing-include-dirs
 *                    -Wredundant-decls -Wswitch-default -Wswitch-enum
 *
 *  Execution:    ./...
 *
 *  Description:
 *  Exercise 15.6: Test your print_total function by passing both Quote and
 *  Bulk_quote (PermDiscount) objects to that function.
 *  Exercise 15.17: Try to define an object of type Disc_quote and see what
 *  errors you get from the compiler.
 *  "error: cannot declare variable 'testes' to be of abstract type 'DiscQuote'
 *  because the following virtual functions are pure within 'DiscQuote':
 *  virtual double DiscQuote::net_price(std::size_t) const"
 *  Exercise 15.26: Define the Quote and Bulk_quote copy-control members
 *  to do the same job as the synthesized versions. Give them and the other
 *  constructors print statements that identify which function is running. Write
 *  programs using these classes and predict what objects will be created and
 *  destroyed. Compare your predictions with the output and continue
 *  experimenting until your predictions are reliably correct.
 *  Exercise 15.28: Define a vector to hold Quote objects but put Bulk_quote
 *  objects into that vector. Compute the total net_price of all the elements
 *  in the vector.
 *  Exercise 15.29: Repeat your program, but this time store shared_ptrs to
 *  objects of type Quote. Explain any discrepancy in the sum generated by the
 *  this version and the previous program. If there is no discrepancy, explain
 *  why there isn’t one.
 *    ** In 15.28 there's no polymorphism. We have only Quote objects.
 *    ** In 15.29 because pointers
 *  Exercise 15.30: Write your own version of the Basket class and use it to
 *  compute prices for the same transactions as you used in the previous
 *  exercises.
 *
 *  Bugs:
 *  --- None ---
 *
 *  TODO:
 *  --- None ---
 *
 *  Notes:
 *  ---
 *
********************************************************************************
*******************************************************************************/


#include <iostream>
#include <utility>      // std::move

#include "Quote.h"
#include "Discounts.h"
#include "Functions.h"
#include "Person.h"
#include "Basket.h"


void ex15_6(void);
void ex15_26(void);
void ex15_28(void);
void ex15_29(void);
void ex15_30(void);


int main()
{

    ex15_30();

    std::cout << "\n\n";
    return 0;
}

void ex15_6(void)
{
    std::string dashes(77, '-');
    std::cout << "\n\n";

    PermDiscount newPrint("Another", 79.9, 3, 0.3);
    LimitedDiscount another("Yet Another", 49.9, 5, 0.3);

    Functions::print_total(newPrint, 10);
    newPrint.debug();
    std::cout << '\n' << dashes << "\n\n";

    Functions::print_total(another, 5);
    another.debug();
    std::cout << '\n' << dashes << "\n\n";
}


void ex15_26(void)
{
    std::string dashes(77, '-');
    std::cout << "\n\n";


    // Test the default constructor
    BulkQuote bulk;
    bulk.debug();
    std::cout << '\n' << dashes << "\n\n";

    // Test the 4 arguments contructor
    BulkQuote bulk2("Coolest Book", 100, 20, 0.2);
    bulk2.debug();
    std::cout << '\n' << dashes << "\n\n";

    // Test the copy constructor
    BulkQuote bulk3(bulk);
    bulk3.debug();
    std::cout << '\n' << dashes << "\n\n";

    // Test the copy assignment operator
    bulk3 = bulk2;
    bulk3.debug();
    std::cout << '\n' << dashes << "\n\n";

    // Test the move constructor
    BulkQuote bulk4(std::move(bulk3));
    bulk4.debug();
    std::cout << '\n' << dashes << "\n\n";

    // Test the move-assignment operator
    bulk4 = std::move(bulk);
    bulk4.debug();
    std::cout << '\n' << dashes << "\n\n";


    // And at the end we should have 4 pairs of 3 destructors called in
    // reverse order from the one of when the objects were created.

    std::cout << '\n' << dashes << "\n\n";
}


void ex15_28(void)
{
    Person A("Ilie");
    A.buy_book("Harry Potter", 50);
    A.buy_book("Margelatu'", 299.07);
    A.show_books();
    A.print_total_price();

    std::cout << "\n" << std::string(70, '-') << std::endl;


    Person B("Ilie");
    BulkQuote book1("Harry Potter", 50, 1, 0.2);
    BulkQuote book2("Margelatu'", 299.534, 1, 0.05);
    B.buy_book(&book1);
    B.buy_book(&book2);
    B.show_books();
    B.print_total_price();
}


void ex15_30(void)
{
    Quote A("Harry Potter", 50);
    //BulkQuote B("Harry Potter", 50, 3, 0.2);
    BulkQuote C("Satra", 44, 6, 0.4);

    Basket AA, BB;
    AA.add_item(A);
    AA.add_item(BulkQuote("Harry Potter", 50, 2, 0.2));
    BB.add_item(C);

    std::cout << "\nFirst buyer\n";
    AA.total_receipt();
    std::cout << "\nSecond buyer\n";
    BB.total_receipt();
}